package service

import (
	"context"

	"github.com/music-gang/music-gang-api/app/apperr"
	"github.com/music-gang/music-gang-api/app/entity"
)

// ContractSearchService is the interface for searching contracts and revisions.
type ContractSearchService interface {
	// FindContractByID returns the contract with the given id.
	// Return ENOTFOUND if the contract does not exist.
	FindContractByID(ctx context.Context, id int64) (*entity.Contract, error)

	// FindContracts returns a list of contracts filtered by the given options.
	// Also returns the total count of contracts.
	FindContracts(ctx context.Context, filter ContractFilter) (entity.Contracts, int, error)

	// FindRevisionByContractAndRev returns the revision searched by the given contract and revision number.
	// Return ENOTFOUND if the revision does not exist.
	FindRevisionByContractAndRev(ctx context.Context, contractID int64, rev entity.RevisionNumber) (*entity.Revision, error)
}

// ContractManagmentService is the interface for managing contracts.
// It is used to create, update and delete contracts.
// Also is used to create new contract revisions.
type ContractManagmentService interface {
	// CreateContract creates a new contract.
	// Return EINVALID if the contract is invalid.
	// Return EEXISTS if the contract already exists.
	// Return EFORBIDDEN if the user is not allowed to create a contract.
	// Return EUNAUTHORIZED if the contract owner is not the authenticated user.
	CreateContract(ctx context.Context, contract *entity.Contract) error

	// DeleteContract deletes the contract with the given id.
	// Return EUNAUTHORIZED if the contract is not the same as the authenticated user.
	// Return ENOTFOUND if the contract does not exist.
	// This service also deletes the revisions of the contract.
	DeleteContract(ctx context.Context, id int64) error

	// MakeRevision creates a new revision of the contract.
	// Return ENOTFOUND if the contract does not exist.
	// Return EINVALID if the revision is invalid.
	// It shouldn't return ECONFLICT because the revision is generated by the database and most likely there should be a UNIQUE constraint on the revision number and the Contract ID.
	MakeRevision(ctx context.Context, revision *entity.Revision) error

	// UpdateContract updates the given contract.
	// Return ENOTFOUND if the contract does not exist.
	// Return EUNAUTHORIZED if the contract is not owned by the authenticated user.
	UpdateContract(ctx context.Context, id int64, contract ContractUpdate) (*entity.Contract, error)
}

// ContractCallOpt defines the options for calling a contract.
type ContractCallOpt struct {
	ContractRef      *entity.Contract
	RevisionRef      *entity.Revision
	ContractStateRef *entity.ContractState
}

// Contract returns the contract attached to the contract call options.
func (opt ContractCallOpt) Contract() (*entity.Contract, error) {
	if opt.ContractRef != nil {
		return opt.ContractRef, nil
	}
	if opt.RevisionRef != nil && opt.RevisionRef.Contract != nil {
		return opt.RevisionRef.Contract, nil
	}
	return nil, apperr.Errorf(apperr.EINVALID, "No contract specified")
}

// Revision returns the revision attached to the contract call options.
func (opt ContractCallOpt) Revision() (*entity.Revision, error) {
	if opt.RevisionRef != nil {
		return opt.RevisionRef, nil
	}
	if opt.ContractRef != nil && opt.ContractRef.LastRevision != nil {
		return opt.ContractRef.LastRevision, nil
	}
	return nil, apperr.Errorf(apperr.EINVALID, "No revision specified")
}

// ContractExecutorService rapresents the contract executor service.
type ContractExecutorService interface {
	// ExecContract executes a contract.
	ExecContract(ctx context.Context, opt ContractCallOpt) (res interface{}, err error)
}

// ContractService rapresents the contract managment service.
// Except for search services, it is required that in passed context is injected the user who try to access this repository, otherwise it will return EUNAUTHORIZED.
type ContractService interface {
	ContractSearchService
	ContractManagmentService
}

// ContractFilter represents the options used to filter the contracts.
type ContractFilter struct {
	ID          *int64  `json:"id"`
	Name        *string `json:"name"`
	Description *string `json:"description"`
	UserID      *int64  `json:"user_id"`

	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// RevisionFilter represents the options used to filter the revisions of a contract.
type RevisionFilter struct {
	// ContractID is not a pointer because should be a mandatory field and honestly i prefer check for zero value istead of nil.
	// It is not possible to filter by contract id if it is not present.
	ContractID int64                  `json:"contract_id"`
	Rev        *entity.RevisionNumber `json:"number"`

	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// ContractUpdate represents the options used to update the contracts.
type ContractUpdate struct {
	Name        *string      `json:"name"`
	Description *string      `json:"description"`
	MaxFuel     *entity.Fuel `json:"max_fuel"`
}
