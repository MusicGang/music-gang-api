package service

import (
	"context"

	"github.com/music-gang/music-gang-api/app/entity"
)

// ContractService rapresents the contract managment service.
// Except for search services, it is required that in passed context is injected the user who try to access this repository, otherwise it will return EUNAUTHORIZED.
type ContractService interface {

	// CreateContract creates a new contract.
	// Return EINVALID if the contract is invalid.
	// Return EEXISTS if the contract already exists.
	// Return EFORBIDDEN if the user is not allowed to create a contract.
	// Return EUNAUTHORIZED if the contract owner is not the authenticated user.
	CreateContract(ctx context.Context, contract *entity.Contract) error

	// DeleteContract deletes the contract with the given id.
	// Return EUNAUTHORIZED if the contract is not the same as the authenticated user.
	// Return ENOTFOUND if the contract does not exist.
	// This service also deletes the revisions of the contract.
	DeleteContract(ctx context.Context, id int64) error

	// FindContractByID returns the contract with the given id.
	// Return ENOTFOUND if the contract does not exist.
	FindContractByID(ctx context.Context, id int64) (*entity.Contract, error)

	// FindContracts returns a list of contracts filtered by the given options.
	// Also returns the total count of contracts.
	FindContracts(ctx context.Context, filter ContractFilter) (entity.Contracts, int, error)

	// MakeRevision creates a new revision of the contract.
	// Return ENOTFOUND if the contract does not exist.
	// Return EINVALID if the revision is invalid.
	// It shouldn't return ECONFLICT because the revision is generated by the database and most likely there should be a UNIQUE constraint on the revision number and the Contract ID.
	MakeRevision(ctx context.Context, id int64, revision *entity.Revision) error

	// UpdateContract updates the given contract.
	// Return ENOTFOUND if the contract does not exist.
	// Return EUNAUTHORIZED if the contract is not owned by the authenticated user.
	UpdateContract(ctx context.Context, id int64, contract ContractUpdate) (*entity.Contract, error)
}

// ContractFilter represents the options used to filter the contracts.
type ContractFilter struct {
	ID          *int64  `json:"id"`
	Name        *string `json:"name"`
	Description *string `json:"description"`
	UserID      *int64  `json:"user_id"`

	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// ContractUpdate represents the options used to update the contracts.
type ContractUpdate struct {
	Name        *string `json:"name"`
	Description *string `json:"description"`
}

// ContractCall rappresents a request from an user to call a contract.
type ContractCall struct {
	ctx      context.Context
	Contract *entity.Contract `json:"contract"`
	Caller   *entity.User     `json:"caller"`
}

// NewContractCall creates a new ContractCall.
func NewContractCall(ctx context.Context, contract *entity.Contract, caller *entity.User) *ContractCall {
	return &ContractCall{
		ctx:      ctx,
		Contract: contract,
		Caller:   caller,
	}
}

// ContractExecutorService rapresents the contract executor service.
type ContractExecutorService interface {
	// ExecContract executes a contract.
	ExecContract(ctx context.Context, contractRef *ContractCall) (res interface{}, err error)
}
